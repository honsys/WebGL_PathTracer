<html>

	<head>
	<title>WebGL Path Tracing</title>
	<meta charset ="utf-8">
	<meta http-equiv="X-UA-Compatible" content="chrome=1">  <!-- Use Chrome Frame in IE --> 
	</head>

	<body>
    <div class="text" style=" text-align:center;"><h1>WebGL Path Tracing</h1></div>
	<div id="message" style="position:absolute;top:100px"></div> <!-- Pixel offset to avoid FPS counter -->
	<canvas id="canvas" style="border: none;" width="1024" height="768" tabindex="1"></canvas>

<script id="vs" type="x-shader/x-vertex">
precision highp float;

attribute vec2 aVertex;
attribute vec3 aPixel;
uniform vec3 vcameraPos;
uniform mat4 u_vInvMP;

varying vec3 vPosition;
varying vec3 InitRay;

void main(void)
{
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vec2 percent = aVertex.xy * 0.5 + 0.5;
    vec3 ray00 = ((u_vInvMP* vec4(-1.0, -1.0, 0.0, 1.0))/(u_vInvMP* vec4(-1.0, -1.0, 0.0, 1.0)).w).xyz - vcameraPos;
    vec3 ray01 = ((u_vInvMP* vec4(-1.0, 1.0, 0.0, 1.0))/(u_vInvMP* vec4(-1.0, -1.0, 0.0, 1.0)).w).xyz - vcameraPos;
    vec3 ray10 = ((u_vInvMP* vec4(1.0, -1.0, 0.0, 1.0))/(u_vInvMP* vec4(-1.0, -1.0, 0.0, 1.0)).w).xyz - vcameraPos;
    vec3 ray11 = ((u_vInvMP* vec4(1.0, 1.0, 0.0, 1.0))/(u_vInvMP* vec4(-1.0, -1.0, 0.0, 1.0)).w).xyz - vcameraPos;
    InitRay = mix(mix(ray00, ray01, percent.y), mix(ray10, ray11, percent.y), percent.x);
    vPosition = aPixel;
}

</script>
<script id="fs" type="x-shader/x-fragment">
precision highp float;

uniform float time;
uniform vec3 cameraPos;

varying vec3 vPosition;
varying vec3 InitRay;

struct RAY{
	vec3 origin;
	vec3 dir;
    vec3 raycolor;
//	bool isInside;
	float IOR;
	//bool continueFlag;//if the ray is alive
};

struct GEOM{
	vec3 pos;
	vec3 scale;
	vec3 rotation;
	vec3 color;
	int type;
	int reflective;
	int refractive;	
	float indexOfRefraction;		
	int textureType;
	int emittance;
	float radius;
	int subsurfaceScatter;
	float reflectivity;	
};
	
struct INTERSECT{
	vec3 IntersectP;
	vec3 IntersectN;
	vec3 color;
	int reflective;//identify whether the currently intersected object is reflective
	int refractive;
	float indexOfRefraction;	
	int emittance;
	int subsurfaceScatter;
	float reflectivity;
};

GEOM geomList[3];
const int numberOfObjects = 3;
float sphereRad = 1.0;


void initializeGeometry(){
	geomList[0].pos = vec3(-2.0,1.0,-1.0);
	geomList[0].color = vec3(1,0,0);
	geomList[0].type = 0 ;//sphere
	geomList[0].reflective = 1;//not reflective
	geomList[0].refractive = 0;//not refractive
	geomList[0].indexOfRefraction = 1.09;
	geomList[0].emittance = 0;
	geomList[0].radius = 1.0;
	geomList[0].subsurfaceScatter = 1;
	geomList[0].reflectivity = 0.2;
    		
	//light
	geomList[1].pos = vec3(-2.0,-1.0,1.0);
	geomList[1].color = vec3(1,1,1);
	geomList[1].type = 0 ;//sphere
	geomList[1].reflective = 0;//not reflective
	geomList[1].refractive = 0;//not refractive*/
	geomList[1].indexOfRefraction = 1.0; 
	geomList[1].emittance = 1;
	geomList[1].scale = vec3(1.0,0.1,1.0);
	geomList[1].subsurfaceScatter = 0;
	geomList[1].reflectivity = 0.0;			
    
    
    //box
    geomList[2].pos = vec3(0.0,1.0,-1.0);
    geomList[2].color = vec3(0,1,0);
    geomList[2].type = 2;//cube
    geomList[2].reflective = 0;//not reflective
    geomList[2].refractive = 0;//not refractive*/
    geomList[2].indexOfRefraction = 2.0; 
    geomList[2].emittance = 0;
    geomList[2].scale = vec3(0.7,0.7,0.7);
    geomList[2].subsurfaceScatter = 1;
    geomList[2].reflectivity = 0.0;		 
}

float intersectSphere(GEOM g, vec3 rStart, vec3 rDir, out float t,  out vec3 normal, out vec3 pos) {
	vec3 rOrigin = g.pos - rStart;
	float b = dot(rDir, rOrigin);
	float d = b*b - dot(rOrigin, rOrigin) + g.radius * g.radius;
	if (d < 0.0) {
		return -1.0;
	}
		
	t = b - sqrt(d);
	if (t < 0.0) {
		return -1.0;
	}
	pos = rStart + t * rDir;
	normal = pos - g.pos;
	float len = length(rStart - pos);
	return len;
}

float intersectCube(GEOM g, vec3 rStart, vec3 rDir, out float t, out vec3 norm, out vec3 pos){
	vec3 vertex1 = g.pos - g.scale;
	vec3 vertex2 = g.pos +  g.scale;
	vec3 ro = rStart;
	vec3 rd = rDir;
		
	float t1, t2;
	float temp;
	float tFar = 1000000.0;
	float tNear = -10000000.0;
        /*************************X-axis checking *****************************************/
	if(rd.x == 0.0){
		if(!(ro.x >= vertex1.x && ro.x <= vertex2.x))
			return -1.0;
	}else{
		t1 = (vertex1.x - ro.x) / rd.x;
		t2 = (vertex2.x - ro.x) / rd.x;

		if(t1 > t2){
			temp = t1;
			t1 = t2;
			t2 = temp;
		}
		if(t1 > tNear)
			tNear = t1;
		if(t2 < tFar)
			tFar = t2;
		if(tNear > tFar)
			return -1.0;
		if(tFar < 0.0)
			return -1.0;
	}//X-axis end
		/*************************Y-axis checking *****************************************/
	if(rd.y == 0.0){
		if(!(ro.y >= vertex1.y && ro.y <= vertex2.y))
			return -1.0;
	}else{
		t1 = (vertex1.y - ro.y) / rd.y;
		t2 = (vertex2.y - ro.y) / rd.y;
		if(t1 > t2)	{
			temp = t1;
			t1 = t2;
			t2 = temp;
		}
		if(t1 > tNear)
			tNear = t1;
		if(t2 < tFar)
			tFar = t2;
		if(tNear > tFar)
			return -1.0;
		if(tFar < 0.0)
			return -1.0;
	}//Y-axis end
    /*************************Z-axis checking *****************************************/
	if(rd.z == 0.0){
		if(!(ro.z >= vertex1.z && ro.z <= vertex2.z))
			return -1.0;
	}else{
		t1 = (vertex1.z - ro.z) / rd.z;
		t2 = (vertex2.z - ro.z) / rd.z;
		if(t1 > t2){
			temp = t1;
			t1 = t2;
			t2 = temp;
		}
		if(t1 > tNear)
			tNear = t1;
		if(t2 < tFar)
			tFar = t2;
		if(tNear > tFar)
			return -1.0;
		if(tFar < 0.0)
			return -1.0;
	}//z-axis end

	if(tNear >= -100000.0)
		t = tNear;
	else
		return -1.0;
	float epsilon = 0.005;

	if ( (t > 0.0)  ){
		vec3 IntersectionPoint = ro + rd * t;
		pos = IntersectionPoint;
		vec3 normal = vec3(0.0,0.0,0.0);
		if(IntersectionPoint.x >= vertex2.x - epsilon && IntersectionPoint.x <= vertex2.x + epsilon)
			normal = vec3(1.0, 0.0, 0.0);
		else if(IntersectionPoint.x >= vertex1.x - epsilon && IntersectionPoint.x <= vertex1.x + epsilon)
			normal = vec3(-1.0, 0.0, 0.0);
		else if(IntersectionPoint.y >= vertex2.y - epsilon && IntersectionPoint.y <= vertex2.y + epsilon)
			normal = vec3(0.0, 1.0, 0.0);
		else if(IntersectionPoint.y >= vertex1.y - epsilon && IntersectionPoint.y <= vertex1.y + epsilon)
			normal = vec3(0.0, -1.0, 0.0);
		else if(IntersectionPoint.z >= vertex2.z - epsilon && IntersectionPoint.z <= vertex2.z + epsilon)
			normal = vec3(0.0, 0.0, 1.0);
		else if(IntersectionPoint.z >= vertex1.z - epsilon && IntersectionPoint.z <= vertex1.z + epsilon)
			normal = vec3(0.0, 0.0, -1.0);
		norm = normal;
		return length(rStart - pos);
	}
	return -1.0;
}

bool intersectWorld(RAY r, inout INTERSECT intersect, inout float dist) {
	float t;
	float hitPointDistance = -1.0;
	float closestIntersectionDistance = 100000.0;
	vec3 tempNormal = vec3(0);
	vec3 tempIntersectionPoint = vec3(0);
	vec3 tempColor = vec3(0,0,0);
	vec3 planeColor = vec3(0,0,0);
	for(int i =0;i<numberOfObjects;++i){	
		if(geomList[i].type == 0){
			hitPointDistance = intersectSphere(geomList[i], r.origin, r.dir, t, tempNormal, tempIntersectionPoint);
		}else if(geomList[i].type == 2){
				hitPointDistance = intersectCube(geomList[i], r.origin, r.dir, t, tempNormal, tempIntersectionPoint);
                }

		if(hitPointDistance > 0.0){
			if(hitPointDistance < closestIntersectionDistance){
				closestIntersectionDistance = hitPointDistance;
				if(geomList[i].type == 1)
					tempColor = planeColor;
				else
					tempColor = geomList[i].color;
				intersect.IntersectN = tempNormal;
				intersect.IntersectP = tempIntersectionPoint;
				intersect.color = tempColor;
				intersect.reflective = geomList[i].reflective;
				intersect.refractive = geomList[i].refractive;
				intersect.indexOfRefraction = geomList[i].indexOfRefraction;
				intersect.emittance = geomList[i].emittance;
				intersect.subsurfaceScatter =  geomList[i].subsurfaceScatter ;
				intersect.reflectivity =  geomList[i].reflectivity;
				//dist = t;
			}
		}
	}
	if (closestIntersectionDistance > -1.0){
		//   dist = closestIntersectionDistance;
		return true;
	}else 
		return false;		
}


float random(vec3 noise, float seed) {
	return fract(sin(dot(vPosition + seed, noise)) * 43758.5453 + seed);
}
	
	
vec3 cosineWeightedDirection(float seed, vec3 normal) 
{
	float u = random(vec3(12.9898, 78.233, 151.7182), seed);
	float v = random(vec3(63.7264, 10.873, 623.6736), seed);
			
	float up = sqrt(u); 
	float over = sqrt(1.0 - up * up); 
	float around = v * 3.14 * 2.0;
		
	vec3 directionNotNormal;
	if (abs(normal.x) < 0.577350269189) { 
		directionNotNormal = vec3(1, 0, 0);
	} else if (abs(normal.y) < 0.577350269189) { 
		directionNotNormal = vec3(0, 1, 0);
	} else {
		directionNotNormal = vec3(0, 0, 1);
	}
				
	vec3 perpendicularDirection1 = normalize(cross(normal, directionNotNormal));
	vec3 perpendicularDirection2 = normalize(cross(normal, perpendicularDirection1)); 
		
	return ( up * normal ) + ( cos(around) * over * perpendicularDirection1 ) + ( sin(around) * over * perpendicularDirection2 );
}


int traceIter = 5;
vec3 pathTrace(inout RAY r, int rayDepth, inout vec3 col){
	vec3 colorMask = vec3(1.0);
	float incidentIOR = 1.0;
	float transmittedIOR = 1.0;
	bool internalReflection = false;
	bool reflective = false;
	bool refractive = false;
	
	for (int i = 0; i <5; ++i) {
		INTERSECT intersect;
		float dist = -1.0;
		if (intersectWorld(r, intersect,dist)) {	
			if(intersect.emittance == 1)
			{//is light
				colorMask *= intersect.color;
				col+= colorMask;	//don't know why 5.0 doesn't work
				break;
			}else
            {//Non light object					      									
				incidentIOR = r.IOR;
				transmittedIOR = intersect.indexOfRefraction;
				internalReflection = false;
				
				colorMask *= intersect.color;
				col+= colorMask;																								
				r.origin = intersect.IntersectP + r.dir*0.001;
				r.dir = normalize(cosineWeightedDirection(time + float(i), intersect.IntersectN));		
																						
			}
		}
        else{
			col = vec3(0.0);
			return col;				
		}				
	}			
	return col;   
		
}

void main(void)
{
	initializeGeometry();
	vec3 cameraDir = normalize(vPosition - cameraPos);  
	RAY r;
	r.origin = cameraPos;
	r.dir = normalize(InitRay);//cameraDir;
	r.IOR = 1.0;		
    r.raycolor = vec3(1.0,1.0,1.0);

	vec3 finalCol = vec3(0.0,0.0,0.0); 
	pathTrace(r, 1, finalCol);
	gl_FragColor = vec4(finalCol/5.0, 1.0);
}

</script>

<script src ="js/lib/gl-matrix.js" type ="text/javascript"></script>
<!--<script src="js/lib/sylvester.src.js" type="text/javascript"></script>-->
<script src ="js/webGLUtility.js" type ="text/javascript"></script>
<script src ="js/WebGL_Path_Tracer.js" type ="text/javascript"></script>
<script src="js/lib/dat.gui.min.js" type="text/javascript"></script>
<script src="js/lib/stats.min.js" type="text/javascript" ></script>
</body>

</html>