<html>

	<head>
	<title>WebGL Path Tracing</title>
	<meta charset ="utf-8">
	<meta http-equiv="X-UA-Compatible" content="chrome=1">  <!-- Use Chrome Frame in IE --> 
	</head>

	<body>
    <div class="text" style=" text-align:center;"><h1>WebGL Path Tracing</h1></div>
	<div id="message" style="position:absolute;top:100px"></div> <!-- Pixel offset to avoid FPS counter -->
	<canvas id="canvas" style="border: none;" width="512" height="512" tabindex="1"></canvas>

<script id="vs_pathTracer" type="x-shader/x-vertex">
precision highp float;

attribute vec2 aVertex;
uniform vec3 vcameraPos;
uniform mat4 u_vInvMP;

varying vec3 InitRay;

void main(void)
{
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vec2 percent = aVertex.xy * 0.5 + 0.5;
    vec3 ray00 = ((u_vInvMP* vec4(-1.0, -1.0, 0.0, 1.0))/(u_vInvMP* vec4(-1.0, -1.0, 0.0, 1.0)).w).xyz - vcameraPos;
    vec3 ray01 = ((u_vInvMP* vec4(-1.0, 1.0, 0.0, 1.0))/(u_vInvMP* vec4(-1.0, -1.0, 0.0, 1.0)).w).xyz - vcameraPos;
    vec3 ray10 = ((u_vInvMP* vec4(1.0, -1.0, 0.0, 1.0))/(u_vInvMP* vec4(-1.0, -1.0, 0.0, 1.0)).w).xyz - vcameraPos;
    vec3 ray11 = ((u_vInvMP* vec4(1.0, 1.0, 0.0, 1.0))/(u_vInvMP* vec4(-1.0, -1.0, 0.0, 1.0)).w).xyz - vcameraPos;
    InitRay = mix(mix(ray00, ray01, percent.y), mix(ray10, ray11, percent.y), percent.x);
}

</script>
<script id="fs_pathTracer" type="x-shader/x-fragment">
precision highp float;

uniform float time;
uniform int objnums;
uniform vec3 cameraPos;

uniform float u_iterations;
uniform sampler2D texture;

varying vec3 InitRay;
const int MAX_OBJ_NUM = 10;

uniform vec3 u_objcolors[MAX_OBJ_NUM];
uniform vec2 u_objtypes[MAX_OBJ_NUM]; //type, textureType
uniform vec3 u_objmat1[MAX_OBJ_NUM]; //reflective,refractive,reflectivity
uniform vec3 u_objmat2[MAX_OBJ_NUM]; //indexOfRefraction,subsurfaceScatter, emittance
uniform mat4 u_objmodelview[MAX_OBJ_NUM];
uniform mat4 u_objinvmodelview[MAX_OBJ_NUM];
uniform mat4 u_objinvtransmodelview[MAX_OBJ_NUM];

struct RAY{
	vec3 origin;
	vec3 dir;
    vec3 raycolor;
//	bool isInside;
	float IOR;
	//bool continueFlag;//if the ray is alive
};

struct GEOM{
    mat4 model;
    mat4 invmodel;
    mat4 transinvmodel;
	vec3 color;
	
    int type;
    int textureType;

	int reflective;
	int refractive;	
    float reflectivity;	

	float indexOfRefraction;	
    int subsurfaceScatter;	
	int emittance;
};
	
struct INTERSECT{
	vec3 IntersectP;
	vec3 IntersectN;
	vec3 color;
	int reflective;//identify whether the currently intersected object is reflective
	int refractive;
	float indexOfRefraction;	
	int emittance;
	int subsurfaceScatter;
	float reflectivity;
};

GEOM geomList[MAX_OBJ_NUM];
const int numberOfObjects = MAX_OBJ_NUM;


void initializeGeometry(){
    for(int i=0;i<numberOfObjects;i++)
    {
	    geomList[i].color = u_objcolors[i];

	    geomList[i].type = int(u_objtypes[i][0]);
        geomList[i].textureType = int(u_objtypes[i][1]);

	    geomList[i].reflective = int(u_objmat1[i][0]);
	    geomList[i].refractive = int(u_objmat1[i][1]);
        geomList[i].reflectivity = u_objmat1[i][2];

	    geomList[i].indexOfRefraction = u_objmat2[i][0];
        geomList[i].subsurfaceScatter = int(u_objmat2[i][1]);
	    geomList[i].emittance = int(u_objmat2[i][2]);

	    
        geomList[i].model = u_objmodelview[i];
        geomList[i].invmodel = u_objinvmodelview[i];
        geomList[i].transinvmodel = u_objinvtransmodelview[i];
    } 
}

vec3 getPointOnRay(RAY r, float t){
  return r.origin + (t - 0.0001) * normalize(r.dir);
}

float intersectSphere(GEOM g, vec3 rStart, vec3 rDir, out float t,  out vec3 normal, out vec3 pos) {
    float radius = 0.5;
    vec3 ro = (g.invmodel * vec4(rStart,1.0)).xyz;
    vec3 rd = (normalize(g.invmodel * vec4(rDir,0.0))).xyz;

    float sign=1.0;
	if(sqrt(dot(ro,ro))<radius)
		sign=-1.0;

    RAY rt; 
    rt.origin = ro; 
    rt.dir = rd;

    float vDotDirection = dot(rt.origin, rt.dir);
	float radicand = vDotDirection * vDotDirection - (dot(rt.origin, rt.origin) - radius * radius);
	if (radicand < 0.0){
		return -1.0;
	}

    float squareRoot = sqrt(radicand);
	float firstTerm = -vDotDirection;
	float t1 = firstTerm + squareRoot;
	float t2 = firstTerm - squareRoot;

	if (t1 < 0.0 && t2 < 0.0) {
		return -1.0;
	} else if (t1 > 0.0 && t2 > 0.0) {
		t = min(t1, t2);
	} else {
		t = max(t1, t2);
	}

    vec3 realIntersectionPoint = (g.model *  vec4(getPointOnRay(rt, t), 1.0)).xyz;
	vec3 realOrigin = (g.model * vec4(0,0,0,1)).xyz;

    pos = realIntersectionPoint;
	normal = normalize(sign*(realIntersectionPoint - realOrigin));

    return length(rStart - realIntersectionPoint);
}

float intersectCube(GEOM g, vec3 rStart, vec3 rDir, out float t, out vec3 normal, out vec3 pos){
    vec3 ro = (g.invmodel * vec4(rStart,1.0)).xyz;
    vec3 rd = (normalize(g.invmodel * vec4(rDir,0.0))).xyz;


    RAY rt; 
    rt.origin = ro; 
    rt.dir = rd;

    float sign=1.0;
	if(abs(rt.origin.x)-0.5<0.0&&abs(rt.origin.y)-0.5<0.0&&abs(rt.origin.z)-0.5<0.0)
		sign = -1.0;

	float tnear = -999999.0;
	float tfar = 999999.0;
	float t1,t2,temp;
	for (int i = 0; i < 3; i++) {
		if (rd[i] == 0.0 ) {
			if (ro[i] > 0.5 || ro[i] < -0.5) {
				return -1.0;
			}
		}
		t1 = (-0.5 - ro[i])/rd[i];
		t2 = (0.5 - ro[i])/rd[i];
		if (t1 > t2) {
			temp = t1;
			t1 = t2;
			t2 = temp;
		}
		if (t1 > tnear) {
			tnear = t1;
		}
		if (t2 < tfar) {
			tfar = t2;
		}
		if (tnear > tfar) {
			return -1.0;
		}
		if (tfar < 0.0) {
			return -1.0;
		}
	}

	if (tnear < -0.0001) 
		t=tfar;
	else
		t=tnear;
	
    vec3 P = getPointOnRay(rt, t);
	if(abs(P[0]-0.5)<0.001)
		normal = vec3(1,0,0);
	else if(abs(P[0]+0.5)<0.001)
		normal = vec3(-1,0,0);
	else if(abs(P[1]-0.5)<0.001)
		normal = vec3(0,1,0);
	else if(abs(P[1]+0.5)<0.001)
		normal = vec3(0,-1,0);
	else if(abs(P[2]-0.5)<0.001)
		normal = vec3(0,0,1);
	else if(abs(P[2]+0.5)<0.001)
		normal = vec3(0,0,-1);


    vec3 realIntersectionPoint = (g.model *  vec4(P, 1.0)).xyz;

    pos = realIntersectionPoint;
    normal = normalize(sign * (g.model * vec4(normal,0.0)).xyz);
    return length(rStart - realIntersectionPoint);
}


bool intersectWorld(RAY r, inout INTERSECT intersect, inout float dist) {
	float t;
	float hitPointDistance = -1.0;
	float closestIntersectionDistance = 100000.0;
	vec3 tempNormal = vec3(0);
	vec3 tempIntersectionPoint = vec3(0);
	vec3 tempColor = vec3(0,0,0);
	vec3 planeColor = vec3(0,0,0);
	for(int i =0;i<numberOfObjects;++i){	
        if(i>=objnums)
           break;
		if(geomList[i].type == 0){
			hitPointDistance = intersectSphere(geomList[i], r.origin, r.dir, t, tempNormal, tempIntersectionPoint);
		}
        else if(geomList[i].type == 2)
        {
		    hitPointDistance = intersectCube(geomList[i], r.origin, r.dir, t, tempNormal, tempIntersectionPoint);
        }


		if(hitPointDistance > 0.0){
			if(hitPointDistance < closestIntersectionDistance){
				closestIntersectionDistance = hitPointDistance;
				if(geomList[i].type == 1)
					tempColor = planeColor;
				else
					tempColor = geomList[i].color;
				intersect.IntersectN = tempNormal;
				intersect.IntersectP = tempIntersectionPoint;
				intersect.color = tempColor;
				intersect.reflective = geomList[i].reflective;
				intersect.refractive = geomList[i].refractive;
				intersect.indexOfRefraction = geomList[i].indexOfRefraction;
				intersect.emittance = geomList[i].emittance;
				intersect.subsurfaceScatter =  geomList[i].subsurfaceScatter ;
				intersect.reflectivity =  geomList[i].reflectivity;
			}
		}
	}

	if (closestIntersectionDistance > -1.0)
		return true;
	else 
		return false;		
}


float random(vec3 noise, float seed) {
	return fract(sin(dot(InitRay + seed, noise)) * 43758.5453 + seed);
}
	
	
vec3 calculateRandomDirectionInHemisphere(float seed, vec3 normal) 
{
	float u = random(vec3(12.9898, 78.233, 151.7182), seed);
	float v = random(vec3(63.7264, 10.873, 623.6736), seed);
			
	float up = sqrt(u); 
	float over = sqrt(1.0 - up * up); 
	float around = v * 3.141592 * 2.0;
		
	vec3 directionNotNormal;
	if (abs(normal.x) < 0.577350269189) { 
		directionNotNormal = vec3(1, 0, 0);
	} else if (abs(normal.y) < 0.577350269189) { 
		directionNotNormal = vec3(0, 1, 0);
	} else {
		directionNotNormal = vec3(0, 0, 1);
	}
				
	vec3 perpendicularDirection1 = normalize(cross(normal, directionNotNormal));
	vec3 perpendicularDirection2 = normalize(cross(normal, perpendicularDirection1)); 
		
	return ( up * normal ) + ( cos(around) * over * perpendicularDirection1 ) + ( sin(around) * over * perpendicularDirection2 );
}


const int depth = 6;
vec3 pathTrace(inout RAY r, int rayDepth, inout vec3 col){
	vec3 colorMask = vec3(1.0);
	float incidentIOR = 1.0;
	float transmittedIOR = 1.0;
	bool internalReflection = false;
	bool reflective = false;
	bool refractive = false;
	
	for (int i = 0; i <depth; ++i) {
		INTERSECT intersect;
		float dist = -1.0;
		if (intersectWorld(r, intersect,dist)) {	
			if(intersect.emittance > 0)
			{//is light
				colorMask = colorMask * intersect.color * float(intersect.emittance);
				col = colorMask;	
			    return col;   
			}
            else
            {//Non light object					      									
				colorMask *= intersect.color;
				col+= colorMask;																								
				
				r.dir = normalize(calculateRandomDirectionInHemisphere(time + float(i), intersect.IntersectN));	
                r.origin = intersect.IntersectP + r.dir*0.001;																			
			}
		}
        else{
			col = vec3(0.0,0.0,0.0);
			return col;   		
		}				
	}	
    
    col = vec3(0.0,0.0,0.0);		
	return col;   	
}

void main(void)
{
	RAY r;
	r.origin = cameraPos.xyz;
	r.dir = normalize(InitRay);
	r.IOR = 1.0;		
    r.raycolor = vec3(1.0,1.0,1.0);
    initializeGeometry();
	vec3 finalCol = vec3(0.0,0.0,0.0); 
	pathTrace(r, 1, finalCol);
	//gl_FragColor = vec4(finalCol/5.0, 1.0);
	
	vec3 texCol = texture2D(texture, gl_FragCoord.xy / 512.0).rgb;
	gl_FragColor = vec4(mix( finalCol/5.0, texCol,u_iterations / (1.0+u_iterations)), 1.0);
	
	//float itrColor = 0.01 * u_iterations;
	//gl_FragColor =vec4(vec3(itrColor,itrColor,itrColor)+texCol, 1.0);
}

</script>
<script id="vs_render" type="x-shader/x-vertex">

precision highp float;

attribute vec3 aVertex;

varying vec2 v_texCoord;

void main(void)
{
   v_texCoord = aVertex.xy * 0.5 + 0.5;
   gl_Position = vec4(aVertex, 1.0);
}

</script>
<script id="fs_render" type="x-shader/x-fragment">
precision highp float;

uniform sampler2D texture;
varying vec2 v_texCoord;

void main(void)
{
    gl_FragColor = texture2D(texture, v_texCoord);
}

</script>
<script src ="js/lib/gl-matrix.js" type ="text/javascript"></script>
<script src ="js/webGLUtility.js" type ="text/javascript"></script>
<script src ="js/WebGL_Path_Tracer.js" type ="text/javascript"></script>
<script src="js/lib/dat.gui.min.js" type="text/javascript"></script>
<script src="js/lib/stats.min.js" type="text/javascript" ></script>
</body>

</html>